// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: song_queries.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addLyric = `-- name: AddLyric :one
INSERT INTO lyrics (
    song_id, id, part, lyrics, created_at
) VALUES (
    $1, $2, $3, $3, current_timestamp
) RETURNING song_id, id, part, lyrics
`

type AddLyricParams struct {
	SongID uuid.NullUUID
	ID     uuid.UUID
	Part   sql.NullString
}

func (q *Queries) AddLyric(ctx context.Context, arg AddLyricParams) (Lyric, error) {
	row := q.db.QueryRowContext(ctx, addLyric, arg.SongID, arg.ID, arg.Part)
	var i Lyric
	err := row.Scan(
		&i.SongID,
		&i.ID,
		&i.Part,
		&i.Lyrics,
	)
	return i, err
}

const addTab = `-- name: AddTab :one
INSERT INTO tabs (
    song_id, id, part, tabs, created_at
) VALUES (
     $1, $2, $3, $3, current_timestamp
 ) RETURNING song_id, id, part, tabs
`

type AddTabParams struct {
	SongID uuid.NullUUID
	ID     uuid.UUID
	Part   sql.NullString
}

func (q *Queries) AddTab(ctx context.Context, arg AddTabParams) (Tab, error) {
	row := q.db.QueryRowContext(ctx, addTab, arg.SongID, arg.ID, arg.Part)
	var i Tab
	err := row.Scan(
		&i.SongID,
		&i.ID,
		&i.Part,
		&i.Tabs,
	)
	return i, err
}

const createSong = `-- name: CreateSong :one
INSERT INTO songs (
    set_id, id, title, genre, subgenre, primary_artist, featured_artists, composer, publisher, producers, additional_contributors, explicit_content, lyrics_language, lyrics_publisher, composition_owner, year_of_composition, master_recording_owner, year_of_recording, release_language, created_at
) VALUES (
             $1, $2, $3 ,$4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, current_timestamp
         ) RETURNING set_id, id, name, created_at, updated_at, deleted_at, title, genre, subgenre, primary_artist, featured_artists, composer, publisher, producers, additional_contributors, explicit_content, lyrics_language, lyrics_publisher, composition_owner, year_of_composition, master_recording_owner, year_of_recording, release_language
`

type CreateSongParams struct {
	SetID                  uuid.NullUUID
	ID                     uuid.UUID
	Title                  sql.NullString
	Genre                  sql.NullString
	Subgenre               sql.NullString
	PrimaryArtist          sql.NullString
	FeaturedArtists        sql.NullString
	Composer               sql.NullString
	Publisher              sql.NullString
	Producers              sql.NullString
	AdditionalContributors sql.NullString
	ExplicitContent        sql.NullBool
	LyricsLanguage         sql.NullString
	LyricsPublisher        sql.NullString
	CompositionOwner       sql.NullString
	YearOfComposition      sql.NullInt32
	MasterRecordingOwner   sql.NullString
	YearOfRecording        sql.NullInt32
	ReleaseLanguage        sql.NullString
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRowContext(ctx, createSong,
		arg.SetID,
		arg.ID,
		arg.Title,
		arg.Genre,
		arg.Subgenre,
		arg.PrimaryArtist,
		arg.FeaturedArtists,
		arg.Composer,
		arg.Publisher,
		arg.Producers,
		arg.AdditionalContributors,
		arg.ExplicitContent,
		arg.LyricsLanguage,
		arg.LyricsPublisher,
		arg.CompositionOwner,
		arg.YearOfComposition,
		arg.MasterRecordingOwner,
		arg.YearOfRecording,
		arg.ReleaseLanguage,
	)
	var i Song
	err := row.Scan(
		&i.SetID,
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Title,
		&i.Genre,
		&i.Subgenre,
		&i.PrimaryArtist,
		&i.FeaturedArtists,
		&i.Composer,
		&i.Publisher,
		&i.Producers,
		&i.AdditionalContributors,
		&i.ExplicitContent,
		&i.LyricsLanguage,
		&i.LyricsPublisher,
		&i.CompositionOwner,
		&i.YearOfComposition,
		&i.MasterRecordingOwner,
		&i.YearOfRecording,
		&i.ReleaseLanguage,
	)
	return i, err
}

const deleteSong = `-- name: DeleteSong :exec
UPDATE songs SET deleted_at = current_timestamp
WHERE id = $1
`

func (q *Queries) DeleteSong(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSong, id)
	return err
}

const readSong = `-- name: ReadSong :one
SELECT set_id, id, name, created_at, updated_at, deleted_at, title, genre, subgenre, primary_artist, featured_artists, composer, publisher, producers, additional_contributors, explicit_content, lyrics_language, lyrics_publisher, composition_owner, year_of_composition, master_recording_owner, year_of_recording, release_language FROM songs
WHERE id = $1 LIMIT 1
`

func (q *Queries) ReadSong(ctx context.Context, id uuid.UUID) (Song, error) {
	row := q.db.QueryRowContext(ctx, readSong, id)
	var i Song
	err := row.Scan(
		&i.SetID,
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Title,
		&i.Genre,
		&i.Subgenre,
		&i.PrimaryArtist,
		&i.FeaturedArtists,
		&i.Composer,
		&i.Publisher,
		&i.Producers,
		&i.AdditionalContributors,
		&i.ExplicitContent,
		&i.LyricsLanguage,
		&i.LyricsPublisher,
		&i.CompositionOwner,
		&i.YearOfComposition,
		&i.MasterRecordingOwner,
		&i.YearOfRecording,
		&i.ReleaseLanguage,
	)
	return i, err
}

const readSongs = `-- name: ReadSongs :many
SELECT set_id, id, name, created_at, updated_at, deleted_at, title, genre, subgenre, primary_artist, featured_artists, composer, publisher, producers, additional_contributors, explicit_content, lyrics_language, lyrics_publisher, composition_owner, year_of_composition, master_recording_owner, year_of_recording, release_language FROM songs
`

func (q *Queries) ReadSongs(ctx context.Context) ([]Song, error) {
	rows, err := q.db.QueryContext(ctx, readSongs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.SetID,
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Title,
			&i.Genre,
			&i.Subgenre,
			&i.PrimaryArtist,
			&i.FeaturedArtists,
			&i.Composer,
			&i.Publisher,
			&i.Producers,
			&i.AdditionalContributors,
			&i.ExplicitContent,
			&i.LyricsLanguage,
			&i.LyricsPublisher,
			&i.CompositionOwner,
			&i.YearOfComposition,
			&i.MasterRecordingOwner,
			&i.YearOfRecording,
			&i.ReleaseLanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSong = `-- name: UpdateSong :exec
UPDATE songs
SET title = $2,
    genre = $3,
    subgenre = $4,
    primary_artist = $5,
    featured_artists = $6,
    composer = $7,
    publisher = $8,
    producers = $9,
    additional_contributors = $10,
    explicit_content = $11,
    lyrics_language = $12,
    lyrics_publisher = $13,
    composition_owner = $14,
    year_of_composition = $15,
    master_recording_owner = $16,
    year_of_recording = $17,
    release_language = $18,
    updated_at = current_timestamp
WHERE id = $1
`

type UpdateSongParams struct {
	ID                     uuid.UUID
	Title                  sql.NullString
	Genre                  sql.NullString
	Subgenre               sql.NullString
	PrimaryArtist          sql.NullString
	FeaturedArtists        sql.NullString
	Composer               sql.NullString
	Publisher              sql.NullString
	Producers              sql.NullString
	AdditionalContributors sql.NullString
	ExplicitContent        sql.NullBool
	LyricsLanguage         sql.NullString
	LyricsPublisher        sql.NullString
	CompositionOwner       sql.NullString
	YearOfComposition      sql.NullInt32
	MasterRecordingOwner   sql.NullString
	YearOfRecording        sql.NullInt32
	ReleaseLanguage        sql.NullString
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) error {
	_, err := q.db.ExecContext(ctx, updateSong,
		arg.ID,
		arg.Title,
		arg.Genre,
		arg.Subgenre,
		arg.PrimaryArtist,
		arg.FeaturedArtists,
		arg.Composer,
		arg.Publisher,
		arg.Producers,
		arg.AdditionalContributors,
		arg.ExplicitContent,
		arg.LyricsLanguage,
		arg.LyricsPublisher,
		arg.CompositionOwner,
		arg.YearOfComposition,
		arg.MasterRecordingOwner,
		arg.YearOfRecording,
		arg.ReleaseLanguage,
	)
	return err
}
