// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.9
// source: setlist.proto

package buffs

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SetListServiceClient is the client API for SetListService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SetListServiceClient interface {
	CreateSetList(ctx context.Context, in *CreateSetListRequest, opts ...grpc.CallOption) (*SetList, error)
	ReadSetList(ctx context.Context, in *ReadSetListRequest, opts ...grpc.CallOption) (*SetList, error)
	UpdateSetList(ctx context.Context, in *UpdateSetListRequest, opts ...grpc.CallOption) (*SetList, error)
	DeleteSetList(ctx context.Context, in *DeleteSetListRequest, opts ...grpc.CallOption) (*Empty, error)
}

type setListServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSetListServiceClient(cc grpc.ClientConnInterface) SetListServiceClient {
	return &setListServiceClient{cc}
}

func (c *setListServiceClient) CreateSetList(ctx context.Context, in *CreateSetListRequest, opts ...grpc.CallOption) (*SetList, error) {
	out := new(SetList)
	err := c.cc.Invoke(ctx, "/barband.setlist.SetListService/CreateSetList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setListServiceClient) ReadSetList(ctx context.Context, in *ReadSetListRequest, opts ...grpc.CallOption) (*SetList, error) {
	out := new(SetList)
	err := c.cc.Invoke(ctx, "/barband.setlist.SetListService/ReadSetList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setListServiceClient) UpdateSetList(ctx context.Context, in *UpdateSetListRequest, opts ...grpc.CallOption) (*SetList, error) {
	out := new(SetList)
	err := c.cc.Invoke(ctx, "/barband.setlist.SetListService/UpdateSetList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *setListServiceClient) DeleteSetList(ctx context.Context, in *DeleteSetListRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/barband.setlist.SetListService/DeleteSetList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SetListServiceServer is the server API for SetListService service.
// All implementations must embed UnimplementedSetListServiceServer
// for forward compatibility
type SetListServiceServer interface {
	CreateSetList(context.Context, *CreateSetListRequest) (*SetList, error)
	ReadSetList(context.Context, *ReadSetListRequest) (*SetList, error)
	UpdateSetList(context.Context, *UpdateSetListRequest) (*SetList, error)
	DeleteSetList(context.Context, *DeleteSetListRequest) (*Empty, error)
	mustEmbedUnimplementedSetListServiceServer()
}

// UnimplementedSetListServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSetListServiceServer struct {
}

func (UnimplementedSetListServiceServer) CreateSetList(context.Context, *CreateSetListRequest) (*SetList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSetList not implemented")
}
func (UnimplementedSetListServiceServer) ReadSetList(context.Context, *ReadSetListRequest) (*SetList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadSetList not implemented")
}
func (UnimplementedSetListServiceServer) UpdateSetList(context.Context, *UpdateSetListRequest) (*SetList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSetList not implemented")
}
func (UnimplementedSetListServiceServer) DeleteSetList(context.Context, *DeleteSetListRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSetList not implemented")
}
func (UnimplementedSetListServiceServer) mustEmbedUnimplementedSetListServiceServer() {}

// UnsafeSetListServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SetListServiceServer will
// result in compilation errors.
type UnsafeSetListServiceServer interface {
	mustEmbedUnimplementedSetListServiceServer()
}

func RegisterSetListServiceServer(s grpc.ServiceRegistrar, srv SetListServiceServer) {
	s.RegisterService(&SetListService_ServiceDesc, srv)
}

func _SetListService_CreateSetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSetListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetListServiceServer).CreateSetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/barband.setlist.SetListService/CreateSetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetListServiceServer).CreateSetList(ctx, req.(*CreateSetListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetListService_ReadSetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadSetListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetListServiceServer).ReadSetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/barband.setlist.SetListService/ReadSetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetListServiceServer).ReadSetList(ctx, req.(*ReadSetListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetListService_UpdateSetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSetListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetListServiceServer).UpdateSetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/barband.setlist.SetListService/UpdateSetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetListServiceServer).UpdateSetList(ctx, req.(*UpdateSetListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SetListService_DeleteSetList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSetListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SetListServiceServer).DeleteSetList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/barband.setlist.SetListService/DeleteSetList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SetListServiceServer).DeleteSetList(ctx, req.(*DeleteSetListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SetListService_ServiceDesc is the grpc.ServiceDesc for SetListService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SetListService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "barband.setlist.SetListService",
	HandlerType: (*SetListServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSetList",
			Handler:    _SetListService_CreateSetList_Handler,
		},
		{
			MethodName: "ReadSetList",
			Handler:    _SetListService_ReadSetList_Handler,
		},
		{
			MethodName: "UpdateSetList",
			Handler:    _SetListService_UpdateSetList_Handler,
		},
		{
			MethodName: "DeleteSetList",
			Handler:    _SetListService_DeleteSetList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "setlist.proto",
}
